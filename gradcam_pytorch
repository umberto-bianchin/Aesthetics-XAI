import os
import glob
import torch
import numpy as np
import matplotlib.pyplot as plt
import cv2
from torchvision import models, transforms
from torch.nn import functional as F
from PIL import Image
from pathlib import Path

# Mount Google Drive if using Colab
from google.colab import drive
drive.mount('/content/drive')

MODEL_PATH = '/content/drive/MyDrive/Colab_Notebooks/inception_multiout_final.pth'
IMG_PATH = '/content/drive/MyDrive/Colab_Notebooks/EVA_together/*.jpg'
SAVE_DIR = '/content/drive/MyDrive/Colab_Notebooks/Results'

# Define device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Load model
class MultiOutputInception(torch.nn.Module):
    def __init__(self, base_model):
        super(MultiOutputInception, self).__init__()
        self.base = base_model
        self.gap = torch.nn.AdaptiveAvgPool2d((1, 1))
        self.dropout1 = torch.nn.Dropout(0.5)
        self.fc1 = torch.nn.Linear(2048, 256)
        self.dropout2 = torch.nn.Dropout(0.3)
        self.out = torch.nn.Linear(256, 6)

    def forward(self, x):
        x = self.base(x)
        x = self.gap(x)
        x = torch.flatten(x, 1)
        x = self.dropout1(x)
        x = F.relu(self.fc1(x))
        x = self.dropout2(x)
        return self.out(x)

inception = models.inception_v3(pretrained=True, aux_logits=False)
inception.fc = torch.nn.Identity()  # remove the original classification head
model = MultiOutputInception(inception).to(device)
model.load_state_dict(torch.load(MODEL_PATH, map_location=device))
model.eval()

last_conv_layer = model.base.Mixed_7c

# Preprocessing and heatmap functions
transform = transforms.Compose([
    transforms.Resize((299, 299)),
    transforms.ToTensor(),
    transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])
])

def make_gradcam_heatmap(img_tensor, model, last_conv_layer, score_index):
    activations = []
    gradients = []

    def forward_hook(module, input, output):
        activations.append(output)

    def backward_hook(module, grad_in, grad_out):
        gradients.append(grad_out[0])

    handle_fwd = last_conv_layer.register_forward_hook(forward_hook)
    handle_bwd = last_conv_layer.register_full_backward_hook(backward_hook)

    model.zero_grad()
    output = model(img_tensor)
    loss = output[0, score_index]
    loss.backward()

    activ = activations[0].squeeze(0)  # (C, H, W)
    grads = gradients[0].squeeze(0)    # (C, H, W)

    weights = grads.mean(dim=(1, 2))
    heatmap = torch.sum(weights[:, None, None] * activ, dim=0)
    heatmap = torch.relu(heatmap)
    heatmap /= torch.max(heatmap)
    heatmap = heatmap.detach().cpu().numpy()

    handle_fwd.remove()
    handle_bwd.remove()

    return heatmap

def superimpose_heatmap(heatmap, original_image, alpha=0.4):
    heatmap = cv2.resize(heatmap, (original_image.shape[1], original_image.shape[0]))
    heatmap = 1 - heatmap
    heatmap = np.uint8(255 * heatmap)
    heatmap_color = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)
    superimposed = cv2.addWeighted(original_image, 1 - alpha, heatmap_color, alpha, 0)
    return superimposed

def load_and_preprocess_image(img_path):
    original_img = cv2.imread(img_path)
    original_img = cv2.cvtColor(original_img, cv2.COLOR_BGR2RGB)
    img = Image.open(img_path).convert('RGB')
    img_tensor = transform(img).unsqueeze(0).to(device)
    return img_tensor, original_img

def run_gradcam_on_image(img_path, save_dir=SAVE_DIR):
    image_basename = Path(img_path).stem
    image_folder = os.path.join(save_dir, image_basename)
    os.makedirs(image_folder, exist_ok=True)

    img_tensor, original_img = load_and_preprocess_image(img_path)
    score_names = ['total', 'difficulty', 'visual', 'composition', 'quality', 'semantic']

    for i, score in enumerate(score_names):
        heatmap = make_gradcam_heatmap(img_tensor, model, last_conv_layer, score_index=i)
        cam = superimpose_heatmap(heatmap, original_img)
        save_path = os.path.join(image_folder, f"{image_basename}_{score}.jpg")
        cv2.imwrite(save_path, cv2.cvtColor(cam, cv2.COLOR_RGB2BGR))
        print(f"Saved Grad-CAM of '{image_basename}' for '{score}' in: {save_path}")

image_paths = glob.glob(IMG_PATH)
for image_path in image_paths:
    run_gradcam_on_image(image_path)
